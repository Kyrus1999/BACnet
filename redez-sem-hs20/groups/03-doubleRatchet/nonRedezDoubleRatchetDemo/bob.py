from cryptography.hazmat.primitives.asymmetric.x25519 import X25519PrivateKey, X25519PublicKey

from Crypto.Cipher import AES

from helpers import SymmRatchet, pad, unpad, hkdf, b64
from helpers import serialize_public_key, deserialize_public_key
from helpers import serialize_private_key, deserialize_private_key

from signing import xeddsa_sign

import os



class Bob(object):
    def __init__(self):
        # generate Bob's keys
        (self.IKb, self.SPKb, self.OPKb) = load_bob_keys()
        self.Ns = 0
        self.Nr = 1
        self.PNs = 0
        self.PNr = 1

        # initialize Bob's DH ratchet
        self.DHratchet = X25519PrivateKey.generate()

    def x3dh(self, alice):
        # perform the 4 Diffie Hellman exchanges (X3DH)
        dh1 = self.SPKb.exchange(alice.IKa.public_key())
        dh2 = self.IKb.exchange(alice.EKa.public_key())
        dh3 = self.SPKb.exchange(alice.EKa.public_key())
        dh4 = self.OPKb.exchange(alice.EKa.public_key())
        # the shared key is KDF(DH1||DH2||DH3||DH4)
        self.sk = hkdf(dh1 + dh2 + dh3 + dh4, 32)
        print('[Bob]\tShared key:', b64(self.sk))

    def x3dh_with_keys(self, alice_IKa: X25519PublicKey, alice_EKa: X25519PublicKey):
        # perform the 4 Diffie Hellman exchanges (X3DH)
        dh1 = self.SPKb.exchange(alice_IKa)
        dh2 = self.IKb.exchange(alice_EKa)
        dh3 = self.SPKb.exchange(alice_EKa)
        dh4 = self.OPKb.exchange(alice_EKa)
        # the shared key is KDF(DH1||DH2||DH3||DH4)
        self.sk = hkdf(dh1 + dh2 + dh3 + dh4, 32)
        #print('[Bob]\tShared key:', b64(self.sk))

    def bob_x3dh_over_tcp(self, socket) -> None:
        ###### START X3DH #######
        print("Start X3DH")
        # IKb, SPKb, OPKb
        IKb_bytes = serialize_public_key(self.IKb.public_key())
        SPKb_bytes = serialize_public_key(self.SPKb.public_key())
        OPKb_bytes = serialize_public_key(self.OPKb.public_key())
        DH_ratchet_initial_bytes = serialize_public_key(self.DHratchet.public_key())
        # print("self's Public key of IKb:", IKb_bytes)
        # print("self's Public key of SPKb:", SPKb_bytes)
        # print("self's Public key of OPKb:", OPKb_bytes)
        keys_to_send = b''.join([IKb_bytes, SPKb_bytes, OPKb_bytes, DH_ratchet_initial_bytes])
        socket.send(keys_to_send)

        msg = socket.recv(64)
        IKa_bytes = msg[:32]
        EKa_bytes = msg[32:]
        # print("msg received:", msg)
        # print("IKa_bytes", IKa_bytes)
        # print("EKa_bytes", EKa_bytes)
        IKa = deserialize_public_key(IKa_bytes)
        EKa = deserialize_public_key(EKa_bytes)
        self.x3dh_with_keys(alice_IKa=IKa, alice_EKa=EKa)
        self.init_ratchets()
        print("Shared Key:", b64(self.sk))
        print("Finished X3DH")
        ######  END X3DH  #######

    def x3dh_1_create_prekey_bundle(self) -> bytes:
        # Initial key packet contains:
        # - [32] DH_ratchet_public_key: DH_ratchet_initial_bytes
        # - [32] Bob's identity key: IKb
        # - [32] Bob's signed prekey: SPKb
        # - [32] One one-time prekey: OPKb
        # - [32] Public key of the signature: signature_pubkey
        # - [64] Bob's prekey signature Sig(Encode(IKb), Encode(SPKb)): signature
        #
        # DH_ratchet_public_key || IKb || SPKb || OPKb || signature_pubkey || signature
        #        32             || 32  ||  32  ||  32  ||        32        ||    64
        # Total length: 224 bytes
        #
        # signature_pubkey and signature are generated by calling xed_sign(keys).
        #   signature_pubkey, signature = signing.xed_sign(keys),
        # where keys is the composition of the 3 keys: DH_ratchet_pubkey, IKb, OPKb.
        # After that we send 224 bytes: keys || signature_pubkey || signature

        ###### START X3DH #######
        print("Start X3DH")
        # IKb, SPKb, OPKb
        IKb_bytes = serialize_public_key(self.IKb.public_key())
        SPKb_bytes = serialize_public_key(self.SPKb.public_key())
        OPKb_bytes = serialize_public_key(self.OPKb.public_key())
        DH_ratchet_initial_bytes = serialize_public_key(self.DHratchet.public_key())
        # print("self's Public key of IKb:", IKb_bytes)
        # print("self's Public key of SPKb:", SPKb_bytes)
        # print("self's Public key of OPKb:", OPKb_bytes)
        keys = b''.join([DH_ratchet_initial_bytes, IKb_bytes, SPKb_bytes, OPKb_bytes])
        signature_pubkey, signature = xeddsa_sign(keys)
        keys_to_send = b''.join([keys, signature_pubkey, signature])

        return keys_to_send


    def x3dh_2_complete_transaction_with_alice_keys(self, msg: bytes):
        assert(len(msg) == 64)
        IKa_bytes = msg[:32]
        EKa_bytes = msg[32:]
        # print("msg received:", msg)
        # print("IKa_bytes", IKa_bytes)
        # print("EKa_bytes", EKa_bytes)
        IKa = deserialize_public_key(IKa_bytes)
        EKa = deserialize_public_key(EKa_bytes)
        self.x3dh_with_keys(alice_IKa=IKa, alice_EKa=EKa)
        self.init_ratchets()
        print("Shared Key:", b64(self.sk))
        print("Finished X3DH")
        ######  END X3DH  #######

        pass

    def init_ratchets(self):
        # initialize the root chain with the shared key
        self.root_ratchet = SymmRatchet(self.sk)
        # initialize the sending and recving chains
        self.recv_ratchet = SymmRatchet(self.root_ratchet.next()[0])
        self.send_ratchet = SymmRatchet(self.root_ratchet.next()[0])
        # initialize Bob's DH ratchet (We do this in the initialization of Bob instead of here.)
        #self.DHratchet = X25519PrivateKey.generate()

    def create_message_event(self):
        raise NotImplementedError


key_length = 290
path_keys_bob = os.getcwd() + '/keys_bob.key'
def load_bob_keys() -> (X25519PrivateKey, X25519PrivateKey, X25519PrivateKey):
    # If existing, load the saved keys for bob.
    # If they do not already exists, generate new keys and save them.
    # Generate OPKb once and do not save it.

    # Returns 3 keys:
    # IKb: X25519PrivateKey
    # SPKb: X25519PrivateKey
    # OPKb: X25519PrivateKey

    OPKb = X25519PrivateKey.generate()
    try:
        with open(path_keys_bob, 'rb') as f:
            lines = f.read()
            print(len(lines))
            assert(len(lines) == 2*key_length)
            IKb_bytes = lines[:key_length]
            SPKb_bytes = lines[key_length:]
            IKb = deserialize_private_key(IKb_bytes)
            SPKb = deserialize_private_key(SPKb_bytes)
            print("Loaded saved keys.")
    except FileNotFoundError:
        print("No keys found. Creating new keys...")
        IKb = X25519PrivateKey.generate()
        SPKb = X25519PrivateKey.generate()
        with open(path_keys_bob, 'wb') as f:
            for key in [IKb, SPKb]:
                f.write(serialize_private_key(key))
            print("Keys saved.")
        pass
    return (IKb, SPKb, OPKb)